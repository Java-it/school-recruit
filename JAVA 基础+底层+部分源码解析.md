## 1.创建对象时的堆栈，字符串缓冲池：
  当使用s1=="Java"创建字符串时，JVM首先会判断字符串池里有没有值为"Java"对象，由于此语句是Main方法的第一句，
  字符串池是空的，所以会在字符串池中构建一个值为"Java"的对象，使s1引用该对象。当使用S2=="Java"语句创建字符串时，
  JVM在字符串缓冲池中寻找到相同值的对象，则S2引用S1所引用的java对象。
## 2、error和exception有什么区别? 
  error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。  
  Error（错误）表示系统级的错误和程序不必处理的异常，是java运行环境中的内部错误或者硬件问题。比如：内存资源不足等。对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由Java虚拟机抛出的。  
  Exception（违例）表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。
  Exception又分为`运行时异常，受检查异常`。
## 3.Java中的异常处理机制的简单原理和应用。 
  异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。  
  Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception，Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉.   
  java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。
## 4.JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？ 
  Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。
  在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。
  Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；
  catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；
  throw语句用来明确地抛出一个异常；
  throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；
  finally为确保一段代码不管发生什么异常状况都要被执行；
## 内存回收机制：
内存回收就是释放掉在内存中已经没用的对象。  
首先，要判断怎样的对象是没用的对象。这里有2种方法：  
1.采用标记计数的方法：  
给内存中的对象给打上标记，对象被引用一次，计数就加1，引用被释放了，计数就减一，当这个计数为0的时候，这个对象就可以被回收了。当然，这也就引发了一个问    题：循环引用的对象是无法被识别出来并且被回收的。所以就有了第二种方法：  
2.采用根搜索算法：  
从一个根出发，搜索所有的可达对象，这样剩下的那些对象就是需要被回收的  
判断完了哪些对象是没用的，这样就可以进行回收了  
最简单的，就是直接清空那个需要被回收的对象。但是这又出现了一个问题，就是内存会被分为一块一块的小碎片。  
为了解决这个问题，可以采用第二种方法，就是在之前的基础上将存活的对象给整理一下，使他们变成一个连续的内存，从而释放出连续的较大的内存空间。  
还有一中回收方法就是采用复制的办法：将内存分为2块，一块用来存放对象，另一块用来放着，当存放对象的那块满了以后就将上面存活的对象给复制过来，然后在这块   内存上工作，并且将之前的内存清空，当自己这块满了以后再复制回去，如此反复。  

比较效率的一中做法是将以上的几种方法给结合起来。  
首先将内存分块，分为新生代，老年代和永久代。  
永久代用来存放代码，等一些基本不改变的数据，  
新生代用来存放刚产生的一些对象，新生代又可分为3块。分别为Edon区，Survivor0,survivor1,刚产生的对象是放在Edon区中，当这个区块放满了以后就将其存活的部分复制到survivor0块中，并且将Edon区中的数据清空，等到survivor0满了就将其中的存活的数据放到survivor1中，清空survivor0,垃圾回收到了一定次数还未被回收的对象，就可以放到老年区。一般来说，刚才产生的对象大多是要在下一次垃圾回收的时候就要被回收掉的，只有一小部分对象会被保留下来，这些被保留下来的对象都是比较稳定的，所以在老年区中的对象回收方法可以采用整理的方法，而在Edon区等新生代中采用复制的方法比较好。  
    
垃圾回收他是在虚拟机空闲的时候或者内存紧张的时候执行的，什么时候回收不是由程序员来控制的，这也就是Java比较耗内存的原因之一。  
还有在垃圾回收的时候当检测到对象没有用了，需要被回收的时候并不会马上被回收，而是将其放入到一个准备回收的队列，去执行finalize方法。。然等到下次内存    回收的时候要是他还是没有被任何人引用的话，就将其给回收了。(如果在finalize方法中重新给对象加个引用，这样对象是有可能不会被回收的)不过finalize方法不推荐使用，他跟C++中的析构函数不同，我们既不能确定什么时候他回被回收，也不能保证这个方法一定会被执行。  
## 同步中sleep与wait的区别：
1，wait可以指定时间也可以不指定。  
  sleep必须指定时间。  
2，在同步中时，对cpu的执行权和锁的处理不同。  
  wait：释放执行权，释放锁。  
  sleep:释放执行权，不释放锁。  
3.sleep：继承Thread类  
   wait:继承Object类。
   
## 1.Java 运行时环境 
JRE 包含：Java 虚拟机、库凼数、运行 Java 应用程序和 Applet 所必须的文件，JDK（又称 SDK）包含：JRE 的超集、编译器、调试器等开収工具。  
Jre:java运行环境  
Jdk:java开发工具包  

## 2.成员变量和局部变量的区别：  
1，  
成员变量定义在类中，整个类中都可以访问。  
局部变量定义在函数，语句，局部代码块中，只在所属的区域有效。  
2，
成员变量存在于堆内存的对象中。
局部变量存在于栈内存的方法中。
3，
成员变量随着对象的创建而存在，随着对象的消失而消失。
局部变量随着所属区域的执行而存在，随着所属区域的结束而释放。
4，
成员变量都有默认初始化值。
局部变量没有默认初始化值。

## 3.静态代码块：
有些代码必须在项目启动的时候就执行，这种代码是主动执行的(当类被载入时，静态代码块被执行，且只被执行一次，静态块常用来执行类属性的初始化)
类方法不能使用实例变量，但实例变量可以使用类变量。
静态方法中不能使用this,super关键字。

## 4.在子父类中，成员的特点体现。
1，成员变量。
2，成员函数。
3，构造函数。
*/	
//1，成员变量。
/*
当本类的成员和局部变量同名用this区分。
当子父类中的成员变量同名用super区分父类。
this和super的用法很相似。
this:代表一个本类对象的引用。
super：代表一个父类空间。

## 5.函数两个特性：
1，重载。同一个类中。overload
2，覆盖。子类中。覆盖也称为重写，覆写。override
覆盖注意事项：
1，子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限。
2，静态只能覆盖静态，或被静态覆盖。
## 6. 单例设计模式：
设计模式：对问题行之有效的解决方式。其实它是一种思想。
1,单例设计模式。
解决的问题：就是可以保证一个类在内存中的对象唯一性。
必须对于多个程序使用同一个配置信息对象时，就需要保证该对象的唯一性。
如何保证对象唯一性呢？
1，不允许其他程序用new创建该类对象。
2，在该类创建一个本类实例。
3，对外提供一个方法让其他程序可以获取该对象。
步骤：
1，私有化该类构造函数。
2，通过new在本类中创建一个本类对象。
3，定义一个公有的方法，将创建的对象返回。

饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成，

而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。
## 7. 构造函数。
写法特点：
1，函数名和类名相同。
2，不需要定义返回值类型
3，没有具体的返回值。但是有return语句，用于结束构造函数。
使用特点：
1，定义类中，有默认的空参数构造函数。如果已经自定义，那么默认就没有了。
2，构造函数在类有多个，是重载形式体现出来的。

## 8，抽象类和一般类的异同点。
相同点：
抽象类和一般类都是用来描述事物的，都在内部定了成员。
不同：
1，一般类有足够的信息描述事物。
抽象类描述事物的信息有可能不足。
2，一般类中不能定义抽象方法，只能定非抽象方法。
抽象类中可定义抽象方法，同时也可以定义非抽象方法。
3，一般类可以被实例化。
抽象类不可以被实例化。

## Java抽象类中不能有静态的抽象方法。
原因：抽象类是不能实例化的，即不能被分配内存;而static修饰的方法在类实例化之前就已经别分配了内存，这样一来矛盾就出现了：抽象类不能被分配内存，而static方法必须被分配内存。所以抽象类中不能有静态的抽象方法。
另外，定义抽象方法的目的是重写此方法，但如果定义成静态方法就不能被重写。

