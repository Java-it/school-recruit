## 1.创建对象时的堆栈，字符串缓冲池：
  当使用s1=="Java"创建字符串时，JVM首先会判断字符串池里有没有值为"Java"对象，由于此语句是Main方法的第一句，
  字符串池是空的，所以会在字符串池中构建一个值为"Java"的对象，使s1引用该对象。当使用S2=="Java"语句创建字符串时，
  JVM在字符串缓冲池中寻找到相同值的对象，则S2引用S1所引用的java对象。
## 2、error和exception有什么区别? 
  error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。  
  Error（错误）表示系统级的错误和程序不必处理的异常，是java运行环境中的内部错误或者硬件问题。比如：内存资源不足等。对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由Java虚拟机抛出的。  
  Exception（违例）表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。
  Exception又分为`运行时异常，受检查异常`。
## 3.Java中的异常处理机制的简单原理和应用。 
  异常是指java程序运行时（非编译）所发生的非正常情况或错误，与现实生活中的事件很相似，现实生活中的事件可以包含事件发生的时间、地点、人物、情节等信息，可以用一个对象来表示，Java使用面向对象的方式来处理异常，它把程序中发生的每个异常也都分别封装到一个对象来表示的，该对象中包含有异常的信息。  
  Java对异常进行了分类，不同类型的异常分别用不同的Java类表示，所有异常的根类为java.lang.Throwable，Throwable下面又派生了两个子类：Error和Exception，Error 表示应用程序本身无法克服和恢复的一种严重问题，程序只有死的份了，例如，说内存溢出和线程死锁等系统问题。Exception表示程序还能够克服和恢复的问题，其中又分为系统异常和普通异常，系统异常是软件本身缺陷所导致的问题，也就是软件开发人员考虑不周所导致的问题，软件使用者无法克服和恢复这种问题，但在这种问题下还可以让软件系统继续运行或者让软件死掉，例如，数组脚本越界（ArrayIndexOutOfBoundsException），空指针异常（NullPointerException）、类转换异常（ClassCastException）；普通异常是运行环境的变化或异常所导致的问题，是用户能够克服的问题，例如，网络断线，硬盘空间不够，发生这样的异常后，程序不应该死掉.   
  java为系统异常和普通异常提供了不同的解决方案，编译器强制普通异常必须try..catch处理或用throws声明继续抛给上层调用方法处理，所以普通异常也称为checked异常，而系统异常可以处理也可以不处理，所以，编译器不强制用try..catch处理或用throws声明，所以系统异常也称为unchecked异常。
## 4.JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？ 
  Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。
  在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。
  Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；try用来指定一块预防所有异常的程序；
  catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；
  throw语句用来明确地抛出一个异常；
  throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；
  finally为确保一段代码不管发生什么异常状况都要被执行；
## 内存回收机制：
内存回收就是释放掉在内存中已经没用的对象。  
首先，要判断怎样的对象是没用的对象。这里有2种方法：  
1.采用标记计数的方法：  
给内存中的对象给打上标记，对象被引用一次，计数就加1，引用被释放了，计数就减一，当这个计数为0的时候，这个对象就可以被回收了。当然，这也就引发了一个问    题：循环引用的对象是无法被识别出来并且被回收的。所以就有了第二种方法：  
2.采用根搜索算法：  
从一个根出发，搜索所有的可达对象，这样剩下的那些对象就是需要被回收的  
判断完了哪些对象是没用的，这样就可以进行回收了  
最简单的，就是直接清空那个需要被回收的对象。但是这又出现了一个问题，就是内存会被分为一块一块的小碎片。  
为了解决这个问题，可以采用第二种方法，就是在之前的基础上将存活的对象给整理一下，使他们变成一个连续的内存，从而释放出连续的较大的内存空间。  
还有一中回收方法就是采用复制的办法：将内存分为2块，一块用来存放对象，另一块用来放着，当存放对象的那块满了以后就将上面存活的对象给复制过来，然后在这块   内存上工作，并且将之前的内存清空，当自己这块满了以后再复制回去，如此反复。  

比较效率的一中做法是将以上的几种方法给结合起来。  
首先将内存分块，分为新生代，老年代和永久代。  
永久代用来存放代码，等一些基本不改变的数据，  
新生代用来存放刚产生的一些对象，新生代又可分为3块。分别为Edon区，Survivor0,survivor1,刚产生的对象是放在Edon区中，当这个区块放满了以后就将其存活的部分复制到survivor0块中，并且将Edon区中的数据清空，等到survivor0满了就将其中的存活的数据放到survivor1中，清空survivor0,垃圾回收到了一定次数还未被回收的对象，就可以放到老年区。一般来说，刚才产生的对象大多是要在下一次垃圾回收的时候就要被回收掉的，只有一小部分对象会被保留下来，这些被保留下来的对象都是比较稳定的，所以在老年区中的对象回收方法可以采用整理的方法，而在Edon区等新生代中采用复制的方法比较好。  
    
垃圾回收他是在虚拟机空闲的时候或者内存紧张的时候执行的，什么时候回收不是由程序员来控制的，这也就是Java比较耗内存的原因之一。  
还有在垃圾回收的时候当检测到对象没有用了，需要被回收的时候并不会马上被回收，而是将其放入到一个准备回收的队列，去执行finalize方法。。然等到下次内存    回收的时候要是他还是没有被任何人引用的话，就将其给回收了。(如果在finalize方法中重新给对象加个引用，这样对象是有可能不会被回收的)不过finalize方法不推荐使用，他跟C++中的析构函数不同，我们既不能确定什么时候他回被回收，也不能保证这个方法一定会被执行。  
## 同步中sleep与wait的区别：



