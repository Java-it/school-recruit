# 虚拟机内存分配
## 一共分为五块
其中：线程共享区域为：  
1、java堆  
2、方法区  
线程私有区域为：  
3、JVM栈  
4、本地方法栈  
5、程序计数器  
各区域作用：  
## 1、java堆：  
java堆是jvm内存管理中最大的一块，线程共享。在jvm启动的时候创建。此区域唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。但是随着JIT编译   器（即时编译器）的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙变化（对象可能会分配到栈上），所以这种所有对象都分配在堆上  也不是那么绝对的。  
java堆细分为新生代和老年代，新生代又分为Eden空间、From Survivor空间、To Survivor空间，新生代中垃圾回收算法为复制算法，复制算法是先将内存分为连个  部分，一部分用来放入对象，而另一部分暂时不用，当使用的一部分内存要进行垃圾回收的时候会将不需要回收的对象复制保存在另一个空间中，然后再对使用过的那   部分区域进行垃圾回收，这样虽然效率很高，但是很浪费空间，所以一般将新生代分为Eden空间和两个Survivor空间，其大小在HotSpot虚拟机中默认比例为8：1：1，  这样在新生代中采用复制算法回收垃圾效率就很高了，具体回收过程是将Eden区域和From Survivor区域作为对象的存储空间，当要进行垃圾回收的时候先将这两个区域  中不需要回收的对象复制保存在To Survivor区域中，然后再进行垃圾回收。另外有一点是当一个对象在Eden区域和From Survivor区域中存储的时候发现内存不足，这  时会进行内存分配担保，就是将此对象直接存入在老年代中。  
老年代中采用的GC算法为标记-清除算法或者标记-整理算法。标记-清除算法为：首先标记出要进行GC的对象，标记完成后再进行GC。这种算法效率不高，并且会产生很  多内存碎片。标记-整理算法：同样是先对要进行GC的对象进行标记，但是不同的是在标记完成后不是立刻执行GC，而是先将不需要GC的对象移动到一端，然后在边界外  再对要回收的对象进行GC。  
关于对象的分配：对象优先在Eden区域分配，大对象会直接进入老年代，长期存活的对象会进入老年代，这里的长期存活是根据新生代中的对象年龄阈值来定义的，对象  刚分配到新生代的时候年龄为1，每进行一次GC对象的年龄会加1，HotSpot中默认的阈值是15，也就是说对象年龄达到15岁的时候会被分配到老年区，这个值是可以通过  参数配置的。  
在进行垃圾回收的时候新生代GC又叫minor GC，老年代GC可以设置内存容量达到百分比的多少的时候进行GC，老年代的GC又叫Full GC，minor GC时间短，频率高，   而Full GC时间长，频率低。  
## 2、方法区  
方法区又被称为永久区，线程共享，是用来存储已被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区为堆的一个逻辑部分，但是在JDK1.7  的HotSpot中已经将方法区中的字符串常量池移出，部分资料显示JDK1.8已经去除了方法区（不确定）。不过已经可以猜测此区域将会被本地内存逐步取代。  
这个区域很少进行垃圾回收，回收目标主要是针对常量池的回收和对类型的卸载。  
## 3、JVM栈  
JVM栈是线程私有的，它的生命周期与线程相同。JVM栈描述的是java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈  、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  
局部变量表中存放了编译期可知的各种基本数据类型、对象的引用类型。局部变量表中需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配  多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。   
## 4、本地方法栈  
本地方法栈和JVM栈非常相似，它们之间的区别不过是jvm栈是为执行java方法服务，而本地方法栈是为jvm使用到对的本地方法服务。HotSpot虚拟机中直接把本地方法栈和JVM栈合二为一了。  
## 5、程序计数器  
程序计数器是一块较小的内存空间，线程私有。它可以看作是当前线程所执行的字节码的行号指示器。在jvm的概念模型里，字节码解释器工作就是通过改变这个计数器  的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。  
如果线程正在执行的是一个java方法，这个计数器记录的是正在执行的jvm字节码指令的地址；如果正在执行的是本地方法，这个计数器值则为空。  
## 总结：  
在jvm划分的内存区域中JVM栈和本地方法栈可能会抛出StackOverflowError异常和OutOfMemoryError异常。java堆和方法区可能会抛出OutOfMemoryError异常。程序计数器中没有地方规定会抛出这两个异常。  
## 扩展：  
在jvm规范中，StackOverflowError异常为：如果线程请求的栈深度大于JVM允许的栈深度，将抛出StackOverflowError异常。OutOfMemoryError异常：如果jvm可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。  
HotSpot虚拟机中标记要清除的对象方法不是使用引用计数器（有引用的时候计数器+1，引用失效-1，应用为0时回收），而使用的是可达性分析算法：以“GC Roots“的对象为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明这个对象不可达，即这个对象不可用，所以这个对象会被判定为是可回收对象。  

